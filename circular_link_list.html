<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Circular Linked List Visualizer — Addresses</title>
<style>
  :root{
    --bg:#071124;
    --panel:#0b1220;
    --muted:#9aa6b2;
    --accent:#7c3aed;
    --accent-2:#06b6d4;
    --ok:#10b981;
    --danger:#ef4444;
    --card:#0f1726;
  }
  *{box-sizing:border-box}
  body{margin:0;min-height:100vh;background:linear-gradient(180deg,var(--bg),#041023);color:#e6eef8;font-family:Inter,system-ui,Roboto,Arial;padding:22px}
  .app{max-width:1100px;margin:0 auto}
  header{display:flex;justify-content:space-between;align-items:start;gap:12px}
  h1{margin:0;font-size:20px}
  .lead{margin:6px 0 0;color:var(--muted);font-size:13px}
  .controls{display:flex;gap:10px;align-items:center;margin-top:18px;flex-wrap:wrap}
  input[type="text"]{padding:10px 12px;border-radius:8px;border:1px solid rgba(255,255,255,0.04);background:transparent;color:inherit;min-width:140px}
  .btn{background:linear-gradient(90deg,var(--accent),#5b21b6);border:none;padding:10px 12px;border-radius:8px;color:white;cursor:pointer}
  .btn.secondary{background:transparent;border:1px solid rgba(255,255,255,0.06)}
  .panel{margin-top:18px;padding:14px;border-radius:12px;background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));border:1px solid rgba(255,255,255,0.03)}
  .top-row{display:flex;justify-content:space-between;align-items:center}
  .top-row .muted{color:var(--muted);font-size:13px}
  /* visual area */
  .visual-wrap{margin-top:14px;display:flex;flex-direction:column;gap:12px}
  .circle-area{display:flex;flex-wrap:wrap;gap:18px;justify-content:center;align-items:center;min-height:240px;padding:18px;border-radius:10px;background:rgba(255,255,255,0.01);border:1px dashed rgba(255,255,255,0.02);position:relative;overflow:visible}
  /* node box */
  .node {
    width: 180px;
    height: 64px;
    border-radius:10px;
    background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
    display:flex;
    align-items:center;
    gap:8px;
    padding:8px;
    box-shadow:0 8px 20px rgba(2,6,23,0.6);
    transform: translateY(-18px) scale(.98);
    opacity: 0;
    transition: transform 420ms cubic-bezier(.2,.9,.3,1), opacity 320ms;
  }
  .node.show { transform: translateY(0) scale(1); opacity: 1; }
  .node.remove { transform: translateY(20px) scale(.98); opacity: 0; transition: all 360ms ease; }

  .node .data {
    min-width:56px;
    background:linear-gradient(180deg,var(--accent-2),#028ca3);
    color:#012;
    font-weight:800;
    display:flex;
    align-items:center;
    justify-content:center;
    padding:8px;
    border-radius:8px;
    font-size:16px;
  }
  .node .meta {
    flex:1; display:flex;flex-direction:column;align-items:flex-start;justify-content:center;
  }
  .addr { font-size:12px;color:var(--muted); margin-bottom:6px; }
  .ptr {
    display:inline-flex;
    align-items:center;
    gap:8px;
    font-weight:700;
    font-size:13px;
    padding:6px 8px;
    background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
    border-radius:8px;
    color:var(--accent);
    border:1px solid rgba(124,58,237,0.12);
  }
  .ptr .arrow { color: #ffd166; font-weight:900; font-size:14px; margin-right:6px; }
  .footer{display:flex;justify-content:space-between;align-items:center;margin-top:8px;color:var(--muted);font-size:13px}
  .message{min-height:20px;color:var(--muted)}
  /* last -> first curved arrow visual (SVG) */
  .curved-arrow { position:absolute; pointer-events:none; opacity:0.95; }
  /* responsive */
  @media (max-width:820px){
    .node{width: calc(48% - 18px)}
    .circle-area{padding:12px}
  }
</style>
</head>
<body>
  <div class="app">
    <header>
      <div>
        <h1>Circular Linked List — Visualizer (with addresses)</h1>
        <div class="lead">Each node has a memory address when added (e.g. <code>(1000)</code>). The pointer shows the address of the next node. Last node points back to head.</div>
      </div>
      <div class="muted">Interactive • Animated • Teaching-friendly</div>
    </header>

    <div class="controls">
      <input id="valueInput" type="text" placeholder="Value (defaults auto)" />
      <button id="addBtn" class="btn">Add Node</button>
      <button id="removeBtn" class="btn secondary">Remove Head</button>
      <button id="clearBtn" class="btn secondary">Clear</button>
    </div>

    <div class="panel">
      <div class="top-row">
        <div class="muted">Nodes: <span id="count">0</span></div>
        <div class="muted">Address start: <strong>(1000)</strong> &nbsp; increment: <strong>+4</strong></div>
      </div>

      <div class="visual-wrap">
        <div id="circleArea" class="circle-area"></div>
        <!-- svg area for curved arrow connecting last -> first (drawn dynamically) -->
        <svg id="svgOverlay" class="curved-arrow" width="100%" height="100%" style=""></svg>

        <div class="footer">
          <div class="message" id="msg">Status: ready</div>
          <div class="muted">Tip: add several nodes, remove head to see circular pointer updates.</div>
        </div>
      </div>
    </div>
  </div>

<script>
/* Circular Linked List Visualizer
   - Each node: { val, addr }
   - addr starts at 1000 and increases by 4 for each new node
   - Pointer displays address of next node (last -> first)
*/

const circleArea = document.getElementById('circleArea');
const svgOverlay = document.getElementById('svgOverlay');
const valueInput = document.getElementById('valueInput');
const addBtn = document.getElementById('addBtn');
const removeBtn = document.getElementById('removeBtn');
const clearBtn = document.getElementById('clearBtn');
const countEl = document.getElementById('count');
const msgEl = document.getElementById('msg');

let list = [];               // array of nodes: { val, addr, el }
let nextAddress = 1000;      // starting address
const ADDR_INC = 4;          // address increment
let defaultChar = 65;        // 'A' for auto default values

// helper: generate next default data (A, B, C...)
function getNextDefault() {
  const ch = String.fromCharCode(defaultChar);
  defaultChar++;
  if (defaultChar > 90) defaultChar = 65;
  return ch;
}

// initialize default value in input
valueInput.value = getNextDefault();

// render the whole list
function renderList(animated=true) {
  circleArea.innerHTML = '';
  svgOverlay.innerHTML = ''; // clear arrows

  list.forEach((node, i) => {
    const nodeEl = createNodeElement(node, i);
    circleArea.appendChild(nodeEl);
    // attach element reference for later
    node.el = nodeEl;
    // small delay to allow CSS transition
    if (animated) requestAnimationFrame(()=> nodeEl.classList.add('show'));
  });

  countEl.textContent = list.length;
  drawCurvedArrowIfNeeded();
}

// create DOM for a node
function createNodeElement(node, idx) {
  const el = document.createElement('div');
  el.className = 'node';
  el.dataset.idx = idx;

  // left: data
  const data = document.createElement('div');
  data.className = 'data';
  data.textContent = node.val;

  // right: meta (address + pointer to next)
  const meta = document.createElement('div');
  meta.className = 'meta';

  const addr = document.createElement('div');
  addr.className = 'addr';
  addr.textContent = `(${node.addr})`; // e.g. (1000)

  const ptr = document.createElement('div');
  ptr.className = 'ptr';
  const arrow = document.createElement('span');
  arrow.className = 'arrow';
  arrow.textContent = '→';
  const nextAddr = document.createElement('span');
  nextAddr.className = 'nextAddr';
  // compute next address (wrap for circular)
  if (list.length <= 1) {
    nextAddr.textContent = `(${node.addr})`; // points to itself if only one node
  } else {
    const nextIndex = (idx + 1) % list.length;
    nextAddr.textContent = `(${ list[nextIndex] ? list[nextIndex].addr : '—' })`;
  }

  ptr.appendChild(arrow);
  ptr.appendChild(nextAddr);

  meta.appendChild(addr);
  meta.appendChild(ptr);

  el.appendChild(data);
  el.appendChild(meta);

  return el;
}

// update pointer display addresses (call after list changes)
function refreshPointerDisplays() {
  list.forEach((node, i) => {
    if (!node.el) return;
    const nextIndex = (i + 1) % list.length;
    const nextAddrText = list.length ? `(${ list[nextIndex] ? list[nextIndex].addr : node.addr })` : '(—)';
    const ptrSpan = node.el.querySelector('.ptr .nextAddr');
    if (ptrSpan) ptrSpan.textContent = nextAddrText;
    const addrSpan = node.el.querySelector('.addr');
    if (addrSpan) addrSpan.textContent = `(${node.addr})`;
  });
  countEl.textContent = list.length;
}

// draw a curved arrow from last node to first node (visual circular link)
function drawCurvedArrowIfNeeded() {
  // small guard
  if (list.length < 2) {
    svgOverlay.style.display = 'none';
    return;
  }
  svgOverlay.style.display = 'block';

  // find first and last node elements and compute positions (center points)
  const firstEl = list[0].el;
  const lastEl = list[list.length - 1].el;
  if (!firstEl || !lastEl) return;

  // bounding rectangles relative to circleArea
  const containerRect = circleArea.getBoundingClientRect();
  const aRect = lastEl.getBoundingClientRect();
  const bRect = firstEl.getBoundingClientRect();

  // compute center points relative to svg
  const ax = aRect.left + aRect.width/2 - containerRect.left;
  const ay = aRect.top + aRect.height/2 - containerRect.top;
  const bx = bRect.left + bRect.width/2 - containerRect.left;
  const by = bRect.top + bRect.height/2 - containerRect.top;

  // clear previous paths
  svgOverlay.innerHTML = '';

  // create a nice curved path from last -> first
  // control points to make an arc above the nodes
  const dx = bx - ax;
  const dy = by - ay;
  const mx = (ax + bx) / 2;
  const my = (ay + by) / 2 - Math.max(60, Math.abs(dx) * 0.7); // lift the middle
  const path = document.createElementNS('http://www.w3.org/2000/svg','path');
  path.setAttribute('d', `M ${ax} ${ay} Q ${mx} ${my} ${bx} ${by}`);
  path.setAttribute('stroke', '#ffd166');
  path.setAttribute('stroke-width', '2');
  path.setAttribute('fill', 'none');
  path.setAttribute('stroke-linecap','round');
  svgOverlay.appendChild(path);

  // arrowhead
  const arrow = document.createElementNS('http://www.w3.org/2000/svg','polygon');
  // compute a point near bx,by along the path direction for arrow orientation
  // simple approximation: take vector from mid->end
  const vx = bx - mx;
  const vy = by - my;
  const len = Math.sqrt(vx*vx + vy*vy) || 1;
  const ux = vx/len;
  const uy = vy/len;
  // base point for arrow
  const axp = bx - ux*10;
  const ayp = by - uy*10;
  // small perpendicular
  const px = -uy*6;
  const py = ux*6;
  const points = `${bx},${by} ${axp+px},${ayp+py} ${axp-px},${ayp-py}`;
  arrow.setAttribute('points', points);
  arrow.setAttribute('fill', '#ffd166');
  svgOverlay.appendChild(arrow);
}

// add node
function addNode() {
  const v = valueInput.value.trim() || getNextDefault();
  const node = { val: v, addr: nextAddress };
  nextAddress += ADDR_INC;
  list.push(node);
  msgEl.textContent = `Added node "${v}" at address (${node.addr})`;
  renderList(true);
  refreshPointerDisplays();
  // prepare the input next default
  valueInput.value = getNextDefault();
}

// remove head
function removeHead() {
  if (list.length === 0) {
    msgEl.textContent = 'List is already empty';
    return;
  }
  // animate removal of first node
  const firstNode = list[0];
  if (firstNode && firstNode.el) {
    firstNode.el.classList.add('remove');
  }
  setTimeout(() => {
    const removed = list.shift();
    msgEl.textContent = `Removed node "${removed.val}" from address (${removed.addr})`;
    renderList(true);
    refreshPointerDisplays();
  }, 360);
}

// clear list
function clearAll() {
  list = [];
  msgEl.textContent = 'Cleared all nodes';
  renderList(true);
  refreshPointerDisplays();
}

// wiring
addBtn.addEventListener('click', addNode);
removeBtn.addEventListener('click', removeHead);
clearBtn.addEventListener('click', clearAll);

// initial demo nodes (optional) - commented out for a clean start
// addNode(); addNode(); addNode();

</script>
</body>
</html>
