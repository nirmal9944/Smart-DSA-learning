<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Dijkstra Visualization — Step-by-step</title>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
<style>
  :root{
    --bg1:#071124; --bg2:#041023;
    --panel: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
    --muted:#9fb0c8; --accent:#7c3aed; --accent2:#06b6d4;
    --ok:#10b981; --warn:#f59e0b; --danger:#ef4444;
  }
  *{box-sizing:border-box}
  body{
    margin:0; min-height:100vh; font-family:Inter,system-ui,Roboto,Arial;color:#e6eef8;
    background: radial-gradient(1200px 600px at 10% 10%, rgba(124,58,237,0.06), transparent),
                linear-gradient(180deg,var(--bg1),var(--bg2));
    padding:18px;
  }
  .app{max-width:1200px;margin:0 auto}
  header{display:flex;justify-content:space-between;align-items:start}
  h1{margin:0;font-size:20px}
  .lead{color:var(--muted);font-size:13px;margin-top:6px}
  .layout{display:grid;grid-template-columns:1fr 360px;gap:18px;margin-top:18px}
  .card{background:var(--panel);padding:12px;border-radius:12px;border:1px solid rgba(255,255,255,0.03)}
  .canvas{background:linear-gradient(180deg, rgba(255,255,255,0.005), rgba(255,255,255,0.002));border-radius:12px;padding:12px;min-height:620px}
  svg{width:100%;height:560px;display:block}
  .controls{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
  input, select, textarea{padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.04);background:transparent;color:inherit}
  button{padding:8px 10px;border-radius:8px;border:none;background:linear-gradient(90deg,var(--accent),#5b21b6);color:white;cursor:pointer;font-weight:700}
  button.secondary{background:transparent;border:1px solid rgba(255,255,255,0.06);color:var(--muted)}
  .small{padding:6px 8px}
  .muted{color:var(--muted);font-size:13px}
  .sidebar{display:flex;flex-direction:column;gap:12px}
  .section{padding:8px;border-radius:10px;background:rgba(255,255,255,0.01)}
  .panel-title{font-weight:700;margin-bottom:6px}
  /* node styles */
  .node-circle{ fill: url(#nodeGrad); stroke:#02121b; stroke-width:1.5; filter: drop-shadow(0 8px 20px rgba(2,6,23,0.6)); cursor:pointer; transition: transform 220ms; }
  .node-label{ font-weight:800; font-size:13px; fill:#02121b; pointer-events:none; text-anchor:middle; }
  .node-dist{ font-size:11px; fill:#02121b; pointer-events:none; text-anchor:middle; opacity:0.9 }
  .edge-line{ stroke: rgba(255,255,255,0.12); stroke-width:2.2; transition: stroke-width 180ms, stroke 180ms; cursor:pointer; }
  .edge-weight{ font-size:12px; fill:var(--muted); text-anchor:middle; pointer-events:none }
  /* highlights */
  .node-current{ transform: scale(1.08); }
  .node-visited circle{ stroke: var(--ok); stroke-width:3; }
  .edge-relaxed{ stroke:#06b6d4; stroke-width:3.4; }
  .edge-consider{ stroke:#93c5fd; stroke-width:3.0; }
  .edge-chosen{ stroke:#ffd166; stroke-width:3.6; }
  .pq { display:flex; gap:6px; flex-wrap:wrap; padding:6px; background:rgba(255,255,255,0.01); border-radius:8px; }
  .pq-item { padding:6px 8px; background:linear-gradient(90deg,#06b6d4,#7dd3fc); color:#02121b; border-radius:6px; font-weight:700; }
  .steps{ max-height:160px; overflow:auto; padding:6px; background:rgba(255,255,255,0.01); border-radius:6px }
  .graph-actions{display:flex;gap:6px;flex-wrap:wrap}
  .hint{ font-size:13px; color:var(--muted) }
  .statusLine{ font-size:13px; color:var(--muted); margin-top:6px; min-height:20px }
  @media (max-width:980px){ .layout{grid-template-columns:1fr} svg{height:700px} }
</style>
</head>
<body>
  <div class="app">
    <header>
      <div>
        <h1>Dijkstra's Algorithm — Visualizer</h1>
        <div class="lead">Shortest path in weighted graphs (non-negative weights). Step-by-step animation with priority queue & relaxation.</div>
      </div>
      <div class="muted">Interactive • Step/play • Editable graph</div>
    </header>

    <div class="layout">
      <!-- main canvas -->
      <div class="card canvas">
        <svg id="svg" viewBox="0 0 1000 560" preserveAspectRatio="xMinYMin meet">
          <defs>
            <linearGradient id="nodeGrad" x1="0" x2="0" y1="0" y2="1">
              <stop offset="0%" stop-color="#7dd3fc"/><stop offset="100%" stop-color="#06b6d4"/>
            </linearGradient>
          </defs>
          <!-- edges and nodes are drawn dynamically -->
        </svg>
        <div class="statusLine" id="statusLine">Status: ready</div>
      </div>

      <!-- sidebar -->
      <div class="sidebar">
        <div class="card section">
          <div class="panel-title">Graph Controls</div>
          <div class="graph-actions">
            <button id="addNodeBtn" class="small secondary">Add Node (click canvas)</button>
            <button id="addEdgeBtn" class="small secondary">Add Edge (click node → node)</button>
            <button id="clearBtn" class="small secondary">Clear Graph</button>
            <button id="loadSample" class="small">Load Sample</button>
          </div>
          <div style="margin-top:8px" class="hint">Or paste edges (one per line): <br><code>u v w</code> e.g. <code>A B 5</code></div>
          <textarea id="edgeInput" rows="5" placeholder="Example:&#10;A B 4&#10;A C 2&#10;B C 1" style="width:100%;margin-top:6px"></textarea>
          <div style="display:flex;gap:6px;margin-top:6px">
            <button id="loadFromText" class="small">Load Edges</button>
            <button id="exportGraph" class="small secondary">Export</button>
          </div>
        </div>

        <div class="card section">
          <div class="panel-title">Algorithm Controls</div>
          <div style="display:flex;gap:8px;flex-wrap:wrap">
            <select id="sourceSelect"></select>
            <select id="targetSelect"></select>
            <button id="startBtn" class="small">Start Dijkstra</button>
            <button id="stepPrev" class="small secondary">Prev</button>
            <button id="stepNext" class="small">Next</button>
            <button id="playPause" class="small">Play</button>
            <label class="muted" style="display:flex;align-items:center;gap:6px"><input id="speed" type="range" min="200" max="1200" value="600"/>speed</label>
          </div>
          <div style="margin-top:8px" class="muted">Click a node after run to highlight shortest path to it from source.</div>
        </div>

        <div class="card section">
          <div class="panel-title">Visualization</div>
          <div style="display:flex;flex-direction:column;gap:8px">
            <div><strong>Current:</strong> <span id="currentLabel" class="muted">—</span></div>
            <div><strong>Distances:</strong></div>
            <div id="distList" class="muted" style="display:flex;flex-wrap:wrap;gap:6px"></div>
            <div style="margin-top:8px"><strong>Priority Queue</strong></div>
            <div id="pq" class="pq"></div>
            <div style="margin-top:8px"><strong>Steps</strong></div>
            <div id="steps" class="steps"></div>
          </div>
        </div>

        <div class="card section">
          <div class="panel-title">Legend</div>
          <div class="hint">
            <div><span style="color:var(--muted)">Gray edge</span> — untouched</div>
            <div><span style="color:#06b6d4">Cyan edge</span> — relaxed</div>
            <div><span style="color:#ffd166">Yellow edge</span> — chosen in final path</div>
            <div><span style="color:var(--ok)">Green node</span> — finalized/visited</div>
          </div>
        </div>
      </div>
    </div>
  </div>

<script>
/* Dijkstra visualizer
 Features:
  - Editable graph: add nodes by clicking canvas, add edges by clicking nodes, or load sample/textarea.
  - Step recording of algorithm actions: pop node, relax edges, update distances.
  - Priority queue visualization (simple array-based min-queue).
  - Play/Pause/Step controls.
  - After completion, click a node to draw shortest path from source.
*/

// ---------- Graph data ----------
let nodes = {}; // id -> {id, x,y}
let edges = []; // {u,v,w, id}
let svg, ns;
let nodeRadius = 26;
let mode = null; // 'addNode' | 'addEdge' etc.
let addEdgeFrom = null;

let steps = []; // recorded steps for playback
let stepIndex = -1;
let playing = false;
let playTimer = null;

// runtime state used while stepping
let currentDist = {};
let currentPrev = {};
let currentVisited = new Set();
let finalPrev = null;

document.addEventListener('DOMContentLoaded', init);

function init(){
  svg = document.getElementById('svg');
  ns = "http://www.w3.org/2000/svg";
  // UI elements
  document.getElementById('addNodeBtn').onclick = ()=> { mode = 'addNode'; setHint('Click canvas to add node.'); };
  document.getElementById('addEdgeBtn').onclick = ()=> { mode = 'addEdge'; addEdgeFrom = null; setHint('Click source node, then target node to add edge.'); };
  document.getElementById('clearBtn').onclick = clearGraph;
  document.getElementById('loadSample').onclick = loadSample;
  document.getElementById('loadFromText').onclick = loadFromText;
  document.getElementById('exportGraph').onclick = ()=> { navigator.clipboard?.writeText(exportGraph()); alert('Graph JSON copied to clipboard'); };
  document.getElementById('startBtn').onclick = startDijkstra;
  document.getElementById('stepNext').onclick = ()=> { stopAuto(); nextStep(); };
  document.getElementById('stepPrev').onclick = ()=> { stopAuto(); prevStep(); };
  document.getElementById('playPause').onclick = togglePlay;
  document.getElementById('stepNext').disabled = false;
  document.getElementById('sourceSelect').onchange = ()=> resetPlayback();
  document.getElementById('targetSelect').onchange = ()=> {};
  document.getElementById('speed').oninput = ()=> {};
  document.getElementById('svg').addEventListener('click', svgClick);

  // default sample
  loadSample();
}

// ---------- Graph builder helpers ----------
function clearGraph(){
  nodes = {}; edges = []; render();
  resetPlayback();
  setHint('Graph cleared');
}
function loadSample(){
  // sample graph: nodes A..G with weights (non-negative)
  const sampleEdges = [
    ['A','B',4], ['A','C',2], ['B','C',1], ['B','D',5],
    ['C','D',8],['C','E',10],['D','E',2],['D','F',6],
    ['E','F',3],['F','G',1],['E','G',7]
  ];
  // place nodes roughly
  const positions = {
    A:[120,80], B:[300,60], C:[200,170], D:[420,170], E:[360,300], F:[540,270], G:[700,300]
  };
  nodes = {};
  for(const id in positions) nodes[id] = {id, x:positions[id][0], y:positions[id][1]};
  edges = [];
  let idx = 0;
  for(const e of sampleEdges) edges.push({u:e[0], v:e[1], w:+e[2], id:'e'+(idx++)});
  render();
  setHint('Sample loaded — choose source and start.');
  populateNodeSelectors();
  resetPlayback();
}

// load from textarea: lines "u v w"
function loadFromText(){
  const text = document.getElementById('edgeInput').value.trim();
  if(!text){ alert('Paste edge lines in the textarea first'); return; }
  nodes = {}; edges = [];
  const lines = text.split('\n').map(s=>s.trim()).filter(Boolean);
  let idx=0;
  // auto position nodes in circle
  const unique = new Set();
  for(const L of lines){
    const parts = L.split(/\s+/);
    if(parts.length < 3) continue;
    unique.add(parts[0]); unique.add(parts[1]);
  }
  const arr = Array.from(unique);
  const R = 200, cx = 500, cy = 200;
  for(let i=0;i<arr.length;i++){
    const ang = i/arr.length * Math.PI*2;
    nodes[arr[i]] = { id: arr[i], x: cx + Math.cos(ang)*R, y: cy + Math.sin(ang)*R };
  }
  for(const L of lines){
    const parts = L.split(/\s+/);
    if(parts.length < 3) continue;
    const u = parts[0], v = parts[1], w = +parts[2];
    edges.push({u,v,w,id:'e'+(idx++)});
  }
  render();
  populateNodeSelectors();
  setHint('Loaded graph from text');
  resetPlayback();
}

function exportGraph(){
  return JSON.stringify({nodes, edges}, null, 2);
}

// ---------- rendering ----------
function render(){
  // clear svg content except defs
  while(svg.childNodes.length>1) svg.removeChild(svg.lastChild);
  // draw edges (lines with weight labels)
  for(const e of edges){
    const u = nodes[e.u], v = nodes[e.v];
    if(!u || !v) continue;
    // draw line
    const line = document.createElementNS(ns,'line');
    line.setAttribute('x1', u.x); line.setAttribute('y1', u.y);
    line.setAttribute('x2', v.x); line.setAttribute('y2', v.y);
    line.setAttribute('class','edge-line');
    line.setAttribute('id', e.id);
    line.addEventListener('click', (ev)=> { ev.stopPropagation(); selectEdge(e); });
    svg.appendChild(line);
    // weight label at midpoint
    const mx = (u.x+v.x)/2, my = (u.y+v.y)/2;
    const wt = document.createElementNS(ns,'text');
    wt.setAttribute('x', mx); wt.setAttribute('y', my - 8);
    wt.setAttribute('class','edge-weight');
    wt.textContent = e.w;
    svg.appendChild(wt);
  }
  // draw nodes (after edges)
  for(const id in nodes){
    const n = nodes[id];
    const g = document.createElementNS(ns,'g');
    g.setAttribute('transform', `translate(${n.x},${n.y})`);
    g.setAttribute('class','node-g');
    g.setAttribute('data-id', n.id);
    // circle
    const c = document.createElementNS(ns,'circle');
    c.setAttribute('r', nodeRadius);
    c.setAttribute('class','node-circle');
    c.addEventListener('click', (ev)=> { ev.stopPropagation(); nodeClick(n); });
    g.appendChild(c);
    // label
    const label = document.createElementNS(ns,'text');
    label.setAttribute('y', -6);
    label.setAttribute('class','node-label');
    label.textContent = n.id;
    g.appendChild(label);
    // distance label (updated during run)
    const dist = document.createElementNS(ns,'text');
    dist.setAttribute('y', 16);
    dist.setAttribute('class','node-dist');
    dist.setAttribute('data-dist','inf');
    dist.textContent = '∞';
    g.appendChild(dist);
    svg.appendChild(g);
  }
  // re-apply styles for any highlighted elements due to stepIndex state
  refreshVisualState();
}

// ---------- UI interactions ----------
function svgClick(ev){
  const rect = svg.getBoundingClientRect();
  const x = ev.clientX - rect.left;
  const y = ev.clientY - rect.top;
  if(mode === 'addNode'){
    // create new node with auto id (A,B,... or N1...)
    let id = nextNodeId();
    nodes[id] = { id, x, y };
    render(); populateNodeSelectors();
    setHint(`Node ${id} added`);
    resetPlayback();
  } else {
    // reset add edge state if not in addEdge
    // clear mode
  }
}

function nextNodeId(){
  // return next label A,B,C... then A1,A2...
  const existing = Object.keys(nodes);
  for(let c='A'.charCodeAt(0); c<='Z'.charCodeAt(0); c++){
    const s = String.fromCharCode(c);
    if(!existing.includes(s)) return s;
  }
  let i=1; while(existing.includes('N'+i)) i++; return 'N'+i;
}

function nodeClick(node){
  if(mode === 'addEdge'){
    if(!addEdgeFrom){
      addEdgeFrom = node.id;
      setHint(`Selected ${node.id} as source — now click target node`);
    } else {
      const u = addEdgeFrom, v = node.id;
      if(u === v){ setHint('Self-loops are allowed but will be added'); }
      const w = prompt(`Edge weight for ${u} -> ${v} (non-negative)`, '1');
      if(w !== null){
        const weight = Number(w);
        if(isNaN(weight) || weight < 0) { alert('Invalid weight'); }
        else {
          edges.push({u,v,w:weight, id:'e'+(Math.random().toString(36).slice(2,8))});
          render();
          populateNodeSelectors();
          setHint(`Added edge ${u} → ${v} (${weight})`);
          resetPlayback();
        }
      }
      addEdgeFrom = null;
      mode = null;
    }
  } else {
    // normal click - if algorithm finished allow clicking node to show shortest path from source
    if(steps.length && stepIndex === steps.length-1){
      // final state reached - highlight path from source to clicked node
      highlightShortestPath(node.id);
    }
  }
}

function selectEdge(e){
  if(confirm(`Remove edge ${e.u} → ${e.v} (${e.w})?`)){
    edges = edges.filter(x=>x.id !== e.id);
    render(); resetPlayback();
  }
}

function populateNodeSelectors(){
  const src = document.getElementById('sourceSelect');
  const tgt = document.getElementById('targetSelect');
  src.innerHTML = ''; tgt.innerHTML = '';
  for(const id in nodes){
    const opt1 = document.createElement('option'); opt1.value=id; opt1.textContent=id; src.appendChild(opt1);
    const opt2 = document.createElement('option'); opt2.value=id; opt2.textContent=id; tgt.appendChild(opt2);
  }
}

// ---------- Dijkstra algorithm with step recording ----------
function startDijkstra(){
  resetPlayback();
  if(Object.keys(nodes).length === 0){ alert('No nodes in graph'); return; }
  const source = document.getElementById('sourceSelect').value;
  if(!source){ alert('Select source'); return; }
  // build adjacency list (treat edges as undirected)
  const adj = {};
  for(const id in nodes) adj[id] = [];
  for(const e of edges){
    if(adj[e.u]) adj[e.u].push({to:e.v, w:e.w, eid:e.id});
    if(adj[e.v]) adj[e.v].push({to:e.u, w:e.w, eid:e.id}); // undirected
  }

  // Dijkstra using simple priority queue (array of {id,dist})
  const dist = {}; const prev = {};
  for(const id in nodes){ dist[id] = Infinity; prev[id]=null; }
  dist[source]=0;
  const pq = [{id:source, dist:0}];

  // record initial step
  steps.push({type:'start', source});

  // visited set
  const visited = new Set();

  while(pq.length){
    // extract min
    pq.sort((a,b)=>a.dist-b.dist);
    const cur = pq.shift();
    const u = cur.id;
    if(visited.has(u)) continue;
    // record pop
    steps.push({type:'pop', u, dist:dist[u], pqSnapshot: pq.slice()});
    visited.add(u);
    // relax neighbors
    for(const ed of adj[u]){
      const v = ed.to;
      if(visited.has(v)) continue;
      const old = dist[v];
      const nd = dist[u] + ed.w;
      steps.push({type:'consider', u, v, w:ed.w, oldDist:old, newDist:nd, edgeId: ed.eid});
      if(nd < old){
        dist[v] = nd; prev[v]=u;
        pq.push({id:v, dist:nd});
        steps.push({type:'relax', u, v, oldDist:old, newDist:nd, pqSnapshot:pq.slice(), edgeId:ed.eid});
      }
    }
    steps.push({type:'finalize', u}); // finalized node
  }
  // finished - final snapshot
  steps.push({type:'done', dist, prev});
  // render initial (before playback)
  render();
  stepIndex = -1;
  showStepsSummary();
  nextStep(); // go to first step
}

function resetPlayback(){
  steps = []; stepIndex = -1; stopAuto();
  document.getElementById('currentLabel').textContent = '—';
  document.getElementById('pq').innerHTML = '';
  document.getElementById('steps').innerHTML = '';
  currentDist = {};
  currentPrev = {};
  currentVisited = new Set();
  finalPrev = null;
  // reset node dist labels and styles
  for(const id in nodes){
    setNodeDistance(id, '∞');
    setNodeVisited(id,false);
    setNodeCurrent(id,false);
    setEdgeStyleById(null,null);
  }
}

function showStepsSummary(){
  const el = document.getElementById('steps');
  el.innerHTML = '';
  for(let i=0;i<steps.length;i++){
    const s = steps[i];
    const div = document.createElement('div');
    div.textContent = `[${i}] ${describeStepBrief(s)}`;
    el.appendChild(div);
  }
  document.getElementById('steps').scrollTop = document.getElementById('steps').scrollHeight;
}

function describeStepBrief(s){
  if(s.type==='start') return `Start at ${s.source}`;
  if(s.type==='pop') return `Pop ${s.u} (dist=${s.dist})`;
  if(s.type==='consider') return `Consider edge ${s.u}→${s.v} (w=${s.w}) old=${s.oldDist} new=${s.newDist}`;
  if(s.type==='relax') return `Relax: ${s.v} updated ${s.oldDist} → ${s.newDist}`;
  if(s.type==='finalize') return `Finalize ${s.u}`;
  if(s.type==='done') return `Finished`;
  return JSON.stringify(s);
}

// ---------- playback controls ----------
function nextStep(){
  if(stepIndex + 1 >= steps.length - 1) { stepIndex++; renderStep(stepIndex); return; }
  stepIndex++;
  renderStep(stepIndex);
}
function prevStep(){
  if(stepIndex <= 0) { stepIndex = -1; render(); return; }
  stepIndex--;
  renderStep(stepIndex);
}
function togglePlay(){
  if(playing) stopAuto();
  else startAuto();
}
function startAuto(){
  if(playing) return;
  playing = true;
  document.getElementById('playPause').textContent = 'Stop';
  const speed = Number(document.getElementById('speed').value) || 600;
  playTimer = setInterval(()=>{
    if(stepIndex + 1 >= steps.length - 1){ stopAuto(); return; }
    nextStep();
  }, Math.max(120, speed));
}
function stopAuto(){
  if(playTimer) clearInterval(playTimer);
  playTimer = null;
  playing = false;
  document.getElementById('playPause').textContent = 'Play';
}

// ---------- render a step ----------
function renderStep(i){
  if(i < 0){ render(); return; }
  const s = steps[i];
  // If step is 'done' store final prev map for path recon
  if(s.type === 'done'){ finalPrev = s.prev; }
  // update status line
  document.getElementById('statusLine').textContent = `Step [${i}] — ${describeStepBrief(s)}`;
  // apply step effect and update runtime state
  switch(s.type){
    case 'start':
      // initialize currentDist & prev
      currentDist = {}; currentPrev = {}; currentVisited = new Set();
      for(const id in nodes){ currentDist[id] = Infinity; currentPrev[id] = null; setNodeDistance(id,'∞'); setNodeVisited(id,false); setNodeCurrent(id,false); setEdgeStyleById(null,null); }
      currentDist[s.source] = 0; setNodeDistance(s.source, 0);
      updatePQ([{id:s.source, dist:0}]);
      highlightCurrent(null);
      break;

    case 'pop':
      // mark node as current being extracted
      highlightCurrent(s.u);
      // set PQ display to snapshot
      updatePQ(s.pqSnapshot || []);
      // reflect its distance
      setNodeDistance(s.u, s.dist);
      break;

    case 'consider':
      // highlight edge under consideration
      setEdgeStyleById(s.edgeId, 'consider');
      // show consider message
      // no state change yet
      break;

    case 'relax':
      // perform relax: update currentDist & prev
      currentDist[s.v] = s.newDist;
      currentPrev[s.v] = s.u;
      setNodeDistance(s.v, s.newDist);
      // highlight relaxed edge
      setEdgeStyleById(s.edgeId, 'relaxed');
      // PQ snapshot may be provided
      if(s.pqSnapshot) updatePQ(s.pqSnapshot);
      break;

    case 'finalize':
      // mark node as visited/finalized
      setNodeVisited(s.u, true);
      // clear current highlight if it was current
      setNodeCurrent(s.u, false);
      // update current label
      document.getElementById('currentLabel').textContent = s.u;
      break;

    case 'done':
      // final state: set all distances and prev from snapshot
      const rootDist = s.dist || {};
      const rootPrev = s.prev || {};
      for(const id in nodes){
        setNodeDistance(id, (rootDist[id] === Infinity) ? '∞' : rootDist[id]);
        setNodeVisited(id, false);
        setNodeCurrent(id, false);
      }
      updatePQ([]);
      // leave finalPrev for path reconstruction
      finalPrev = rootPrev;
      setHint('Algorithm finished — click a node to highlight shortest path from source.');
      break;
  }
  // update step list highlight
  const stepDivs = document.querySelectorAll('#steps > div');
  stepDivs.forEach((d, idx)=> d.style.opacity = (idx === i ? '1' : '0.6'));
}

// ---------- helpers to manipulate visual elements ----------
function setNodeDistance(nodeId, value){
  const g = svg.querySelector(`g.node-g[data-id="${nodeId}"]`);
  if(!g) return;
  const t = g.querySelector('text.node-dist');
  if(!t) return;
  t.textContent = (value === Infinity || value === '∞') ? '∞' : String(value);
  t.setAttribute('data-dist', (value === '∞' ? 'inf' : String(value)));
}
function setNodeVisited(nodeId, visited){
  const g = svg.querySelector(`g.node-g[data-id="${nodeId}"]`);
  if(!g) return;
  if(visited) g.classList.add('node-visited'); else g.classList.remove('node-visited');
}
function setNodeCurrent(nodeId, isCurrent){
  const g = svg.querySelector(`g.node-g[data-id="${nodeId}"]`);
  if(!g) return;
  if(isCurrent) g.classList.add('node-current'); else g.classList.remove('node-current');
}
function highlightCurrent(nodeId){
  // remove all current
  const gs = svg.querySelectorAll('g.node-g');
  gs.forEach(x => x.classList.remove('node-current'));
  if(nodeId) setNodeCurrent(nodeId, true);
}
function setEdgeStyleById(edgeId, style){
  // style: null | 'consider' | 'relaxed' | 'chosen'
  if(edgeId === null && style === null){
    const lines = svg.querySelectorAll('line.edge-line');
    lines.forEach(l => {
      l.classList.remove('edge-consider', 'edge-relaxed', 'edge-chosen');
    });
    return;
  }
  const line = document.getElementById(edgeId);
  if(!line) return;
  line.classList.remove('edge-consider', 'edge-relaxed', 'edge-chosen');
  if(style === 'consider') line.classList.add('edge-consider');
  if(style === 'relaxed') line.classList.add('edge-relaxed');
  if(style === 'chosen') line.classList.add('edge-chosen');
}

function refreshVisualState(){
  // re-apply visual states from currentDist, currentVisited, etc.
  for(const id in nodes){
    setNodeDistance(id, currentDist[id] !== undefined && currentDist[id] !== Infinity ? currentDist[id] : '∞');
    setNodeVisited(id, currentVisited.has(id));
  }
}

function updatePQ(pq){
  const el = document.getElementById('pq');
  el.innerHTML = '';
  pq.forEach(item => {
    const div = document.createElement('div');
    div.className = 'pq-item';
    div.textContent = `${item.id}(${item.dist})`;
    el.appendChild(div);
  });
}

function highlightShortestPath(targetId){
  if(!finalPrev) return;
  const src = document.getElementById('sourceSelect').value;
  let cur = targetId;
  let pathEdges = new Set();
  while(finalPrev[cur]){
    const u = finalPrev[cur];
    const eid = findEdgeId(u, cur);
    if(eid) pathEdges.add(eid);
    cur = u;
  }
  // Clear all and highlight path edges
  setEdgeStyleById(null, null);
  for(const eid of pathEdges){
    setEdgeStyleById(eid, 'chosen');
  }
}

function findEdgeId(u, v){
  for(const e of edges){
    if((e.u === u && e.v === v) || (e.u === v && e.v === u)){
      return e.id;
    }
  }
  return null;
}

function setHint(text){
  document.getElementById('statusLine').textContent = text;
}
</script>
</body>
</html>